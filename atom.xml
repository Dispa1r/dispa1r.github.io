<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DravenLu</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dispa1r.github.io/"/>
  <updated>2022-05-18T09:57:26.667Z</updated>
  <id>https://dispa1r.github.io/</id>
  
  <author>
    <name>Dispa1r</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The Graph开发心得(NEAR)</title>
    <link href="https://dispa1r.github.io/2022/05/18/The-Graph%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97-NEAR/"/>
    <id>https://dispa1r.github.io/2022/05/18/The-Graph开发心得-NEAR/</id>
    <published>2022-05-18T09:45:29.000Z</published>
    <updated>2022-05-18T09:57:26.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用TheGraph开发链上数据索引的一些总结"><a href="#使用TheGraph开发链上数据索引的一些总结" class="headerlink" title="使用TheGraph开发链上数据索引的一些总结"></a>使用TheGraph开发链上数据索引的一些总结</h1><h2 id="映射部分"><a href="#映射部分" class="headerlink" title="映射部分"></a>映射部分</h2><ul><li>变量命名的坑：这个问题主要出在GraphQL上，graph在查询数据时，对于多条数据查询需要将查询的entity变成复数形式，所以在命名entity时最好需要避开结尾是s，es等情况。</li></ul><p><img src="/uploads/upload_d87e8d6c681ea72a2edf7dca45438e91.png" alt=""></p><ul><li>数据类型映射的问题：The Graph中的基础类型如下图，可以通过定义entity以及entity Array的形式得到任何复杂类型，文档中对于Int类型占用32个字节的说法存疑，BigDecimal可以保存浮点数，并且精度很高</li></ul><p><img src="/uploads/upload_ad874b487fae4c92e84f8ea3001cce4c.png" alt=""></p><ul><li>数据运算：对于Int,BigInt,BigDecimal等数据，graph已经完成了对这些数据类型的运算符的重载，具体支持的计算类型如下：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">namespace</span> bigInt &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">plus</span>(<span class="params">x: <span class="built_in">BigInt</span>, y: <span class="built_in">BigInt</span></span>): <span class="title class_">BigInt</span> <span class="comment">// +</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">minus</span>(<span class="params">x: <span class="built_in">BigInt</span>, y: <span class="built_in">BigInt</span></span>): <span class="title class_">BigInt</span> <span class="comment">// -</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">times</span>(<span class="params">x: <span class="built_in">BigInt</span>, y: <span class="built_in">BigInt</span></span>): <span class="title class_">BigInt</span> <span class="comment">// *</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dividedBy</span>(<span class="params">x: <span class="built_in">BigInt</span>, y: <span class="built_in">BigInt</span></span>): <span class="title class_">BigInt</span> <span class="comment">// /</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dividedByDecimal</span>(<span class="params">x: <span class="built_in">BigInt</span>, y: BigDecimal</span>): <span class="title class_">BigDecimal</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">mod</span>(<span class="params">x: <span class="built_in">BigInt</span>, y: <span class="built_in">BigInt</span></span>): <span class="title class_">BigInt</span> <span class="comment">// %</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">pow</span>(<span class="params">x: <span class="built_in">BigInt</span>, exp: u8</span>): <span class="title class_">BigInt</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fromString</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title class_">BigInt</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bitOr</span>(<span class="params">x: <span class="built_in">BigInt</span>, y: <span class="built_in">BigInt</span></span>): <span class="title class_">BigInt</span> <span class="comment">// |</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bitAnd</span>(<span class="params">x: <span class="built_in">BigInt</span>, y: <span class="built_in">BigInt</span></span>): <span class="title class_">BigInt</span> <span class="comment">// &amp;</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">leftShift</span>(<span class="params">x: <span class="built_in">BigInt</span>, bits: u8</span>): <span class="title class_">BigInt</span> <span class="comment">// &gt;&lt;&lt;</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">rightShift</span>(<span class="params">x: <span class="built_in">BigInt</span>, bits: u8</span>): <span class="title class_">BigInt</span> <span class="comment">// &gt;&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于entity的Array：graph的ArrayList本质上是一个string数组，里面保存的是目标entity的id，因此使用起来较为方便，在向Array作增量更新时直接使用array.push[entity]这种形式是无效的，需要将array原本的内容深拷贝一份后再添加元素，最后进行覆盖才是有效的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确用法：</span></span><br><span class="line"><span class="keyword">let</span> fromUser = <span class="title function_">getOrInitUser</span>(oldOwnerId);</span><br><span class="line"><span class="keyword">let</span> temp = fromUser.<span class="property">transferedOut</span>!;</span><br><span class="line">temp.<span class="title function_">push</span>(receiptHash);</span><br><span class="line">fromUser.<span class="property">transferedOut</span> = temp;</span><br><span class="line">fromUser.<span class="title function_">save</span>();</span><br></pre></td></tr></table></figure><ul><li><p>谨慎使用const：在graph的处理中需要谨慎使用const，如果你可以确保你的graph在进行索引时只会使用到某些同名变量的一次，那么可以使用const，否则还是最好使用let或者var</p></li><li><p>关于handle的粒度：graph支持在receipt层和block层处理索引，需要注意的是跨合约调用的日志会分布在不同的receipt中，需要获取这些日志时，需要指定每个receipt中的函数名，下图是发生在一个区块中不同receipt的案例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blockHandlers:</span><br><span class="line">        - handler: handleNewBlock # the function name in the mapping file</span><br><span class="line">receiptHandlers:</span><br><span class="line">        - handler: handleReceipt # the function name in the mapping file</span><br></pre></td></tr></table></figure><p><img src="/uploads/upload_c9a79904473c0cc160545087d35426ed.png" alt=""></p></li></ul><p><img src="/uploads/upload_a44212bd6c7a98ef73d0e883342476ea.png" alt=""></p><ul><li><p>关于timeStamp：graph中的timeStamp是从区块中获取的而不是直接获取系统时间戳，这一点需要注意</p></li><li><p>关于id选取的一些经验：id是graph的entity中最重要的一个字段，一般来说需要索引的数据会离散的分布在不同的区块中，因此想要避免重复的id可以使用blockHash或者timeStamp，关于实现连续的id再下文中会介绍，下面是区块中的一些unique的信息，可以用来作为id，对于其中bytes类型的数据可以使用graph库中自带的base58编码后即可去浏览器中查询</p></li></ul><p><img src="/uploads/upload_1be2fae75aed53ef44a82a75f1841c44.png" alt="base58编码后的receiptHash"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// block级</span><br><span class="line">class BlockHeader &#123;</span><br><span class="line">      height: u64,</span><br><span class="line">      epochId: Bytes,</span><br><span class="line">      hash: Bytes,</span><br><span class="line">      timestampNanosec: u64,</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line">//  receipt级</span><br><span class="line">class ExecutionOutcome &#123;</span><br><span class="line">      gasBurnt: u64,</span><br><span class="line">      blockHash: Bytes,</span><br><span class="line">      id: Bytes,</span><br><span class="line">      logs: Array&lt;string&gt;,</span><br><span class="line">      receiptIds: Array&lt;Bytes&gt;,</span><br><span class="line">      tokensBurnt: BigInt,</span><br><span class="line">      executorId: string,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>关于实现连续id：对于一些特殊的需求，比如说维护一个值的增长的全过程，此时就需要找到上一条记录的id，这种情况下可以用一个version结构去记录上一条记录的id，并且保存下一条记录的id，这种结构类似于链表，下面是一个最简单的version的实现：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">priceVersion.<span class="property">lastPriceID</span> = priceVersion.<span class="property">nextPriceID</span>;</span><br><span class="line">priceVersion.<span class="property">nextPriceID</span> = priceVersion.<span class="property">nextPriceID</span>.<span class="title function_">plus</span>(<span class="title class_">BigInt</span>.<span class="title function_">fromU32</span>(<span class="number">1</span>));</span><br><span class="line">priceVersion.<span class="property">latestPrice</span> = nextPrice.<span class="property">price</span>;</span><br><span class="line">priceVersion.<span class="title function_">save</span>();</span><br></pre></td></tr></table></figure><ul><li>关于反向查询的一些思考和理解：反向查询本事上是在结构中加入一些虚拟的字段，通过这些字段可以进行反向查询，以NFT场景为例，某些地方需要查询NFT的所属者以及一个用户所持有的全部NFT，这种情况反向查询就显得格外有用，以superise的graph中的反向查询为例，可以这样理解，Array代表了一对多的映射，反向查询则可以代表了多对多的双向映射，完整代码可以在superise的graph仓库中找到</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">TwitterPool</span> @entity&#123;</span><br><span class="line">   <span class="attr">id</span>: <span class="variable constant_">ID</span>!</span><br><span class="line">   <span class="attr">name</span>: <span class="title class_">String</span>!</span><br><span class="line">   <span class="attr">describe</span>: <span class="title class_">String</span>!</span><br><span class="line">   <span class="attr">cover</span>: <span class="title class_">String</span>!</span><br><span class="line">   <span class="attr">status</span>: <span class="title class_">String</span>!</span><br><span class="line">   <span class="attr">end_time</span>: <span class="title class_">BigInt</span>!</span><br><span class="line">   <span class="attr">create_time</span>: <span class="title class_">BigInt</span>!</span><br><span class="line">   <span class="attr">update_time</span>: <span class="title class_">BigInt</span>!</span><br><span class="line">   <span class="attr">white_list</span>: [<span class="title class_">Account</span>!]</span><br><span class="line">   <span class="attr">requirement</span>: <span class="title class_">String</span></span><br><span class="line">   <span class="attr">twitter_link</span>: <span class="title class_">String</span>!</span><br><span class="line">   <span class="attr">winner_account</span>: [<span class="title class_">Account</span>!]</span><br><span class="line">   <span class="attr">winner_record</span>: [<span class="title class_">Record</span>!]</span><br><span class="line">   <span class="attr">creator_id</span>: <span class="title class_">Account</span>!</span><br><span class="line">   <span class="attr">ft_prize</span>: [<span class="variable constant_">FT</span>!]</span><br><span class="line">   <span class="attr">nft_prize</span>: [<span class="variable constant_">NFT</span>!]</span><br><span class="line">   <span class="attr">join_account</span>: [<span class="title class_">Account</span>!]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type <span class="title class_">Account</span> @entity&#123;</span><br><span class="line">   <span class="attr">id</span>: <span class="variable constant_">ID</span>!</span><br><span class="line">   <span class="attr">name</span>: <span class="title class_">String</span>!</span><br><span class="line">   <span class="attr">joined_prize_pool</span>: [<span class="title class_">TwitterPool</span>!]  @<span class="title function_">derivedFrom</span>(<span class="attr">field</span>: <span class="string">&quot;join_account&quot;</span>)</span><br><span class="line">   <span class="attr">whitelist_pool</span>: [<span class="title class_">TwitterPool</span>!]  @<span class="title function_">derivedFrom</span>(<span class="attr">field</span>: <span class="string">&quot;white_list&quot;</span>)</span><br><span class="line">   <span class="attr">created_pool</span>: [<span class="title class_">TwitterPool</span>!] @<span class="title function_">derivedFrom</span>(<span class="attr">field</span>: <span class="string">&quot;creator_id&quot;</span>)</span><br><span class="line">   <span class="attr">winned_pool</span>: [<span class="title class_">TwitterPool</span>!] @<span class="title function_">derivedFrom</span>(<span class="attr">field</span>: <span class="string">&quot;winner_account&quot;</span>)</span><br><span class="line">   <span class="attr">winned_prize</span>: [<span class="title class_">Record</span>!] @<span class="title function_">derivedFrom</span>(<span class="attr">field</span>: <span class="string">&quot;receiver&quot;</span>)</span><br><span class="line">   <span class="attr">sender_activity</span>: [<span class="title class_">Activity</span>!] @<span class="title function_">derivedFrom</span>(<span class="attr">field</span>: <span class="string">&quot;sender&quot;</span>)</span><br><span class="line">   <span class="attr">recevier_activity</span>: [<span class="title class_">Activity</span>!] @<span class="title function_">derivedFrom</span>(<span class="attr">field</span>: <span class="string">&quot;receiver&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>合约中对于event的定义与使用：这种需要结合具体情况具体分析，也许可以针对不同的NEP的标准编写一套对应的graph的模板，或者开发一个event2graph的小工具，其实关于这个问题我之前就有了一些思考，具体可以点击这里看<a href="https://hackmd.summershrimp.com/iurKPePtTC6wJF8mPAvUuw">关于event2graph的一些思考</a></p></li><li><p>关于起始块的选择：通过在yaml文件中配置startBlock可以大大减少sync的耗时，但是如何选择一个起始块是一个比较有意思的问题，最严谨的方法就是使用浏览器查看account创建的时间，当然也可以选择合约发生第一笔交易的时间</p></li></ul><h2 id="部署部分"><a href="#部署部分" class="headerlink" title="部署部分"></a>部署部分</h2><p>部署部分其实相对来说坑比较少，除了graph不定时抽风之外lol</p><ul><li>pending与current version：这里要注意的是，当你试图重新覆盖掉已经sync完成的子图时，graph会自动创建一个pending版本，可以在playground的右上角进行版本的切换。</li></ul><h2 id="调试部分"><a href="#调试部分" class="headerlink" title="调试部分"></a>调试部分</h2><p>关于graph的debug其实一直是一个比较麻烦的问题，重新部署+sync的耗时过长，下面还是有一些小技巧帮助你进行调试：</p><ul><li><p>在一些结构中加入blockHash或者receiptHash，可以去浏览器快速定位到问题区块</p></li><li><p>如果你的graph不小心crash了，你可以在logs中找到出问题的区块高度，然后去分析其中的交易</p></li><li><p>在编写graph时一定要构造一个比较严谨的闭合的生命周期，否则经常会出现一些数据对不上的情况</p></li></ul><h2 id="数据可视化部分"><a href="#数据可视化部分" class="headerlink" title="数据可视化部分"></a>数据可视化部分</h2><p>与Google Sheet、Google Data Studio 联动：这部分主要是把query的脚本改成了Google App Script，这里基于这个<a href="https://towardsdatascience.com/how-to-create-a-ethereum-defi-realtime-dashboard-a60c23b527f7">链接</a>简单做了一个获取转账记录的脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getDataGQL</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> url_query = <span class="string">&#x27;https://api.thegraph.com/subgraphs/name/ha4a4ck/linearmainnet&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> query = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">    ftTransfers(first: 1000,skip: skip_param) &#123;</span></span><br><span class="line"><span class="string">      to &#123;</span></span><br><span class="line"><span class="string">        id</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      from &#123;</span></span><br><span class="line"><span class="string">        id</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      timestamp</span></span><br><span class="line"><span class="string">      amount</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;`</span></span><br><span class="line"></span><br><span class="line">  data = <span class="title function_">getApiData_</span>(url_query, query)</span><br><span class="line">  <span class="title function_">writeData_</span>(data)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates the query with the skip param to iterate all the borrows</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> the query to executed with the skip param replaced</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createOptions_</span>(<span class="params">query</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> options = &#123;</span><br><span class="line">    <span class="string">&#x27;method&#x27;</span> : <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;contentType&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;payload&#x27;</span> : <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">query</span>: query&#125;) </span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Writes the data in the spreadsheet </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> matrix data to write</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">writeData_</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="title class_">Logger</span>.<span class="title function_">log</span>(data.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">var</span> ss = <span class="title class_">SpreadsheetApp</span>.<span class="title function_">getActiveSpreadsheet</span>().<span class="title function_">getActiveSheet</span>();</span><br><span class="line">    ss.<span class="title function_">getRange</span>(<span class="number">2</span>, <span class="number">1</span>, data.<span class="property">length</span>, data[<span class="number">0</span>].<span class="property">length</span>).<span class="title function_">clear</span>()</span><br><span class="line">    ss.<span class="title function_">getRange</span>(<span class="number">2</span>, <span class="number">1</span>, data.<span class="property">length</span>, data[<span class="number">0</span>].<span class="property">length</span>).<span class="title function_">setValues</span>(data);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Gets the data from the api and transform the result </span></span><br><span class="line"><span class="comment">* getting the json data fields to a </span></span><br><span class="line"><span class="comment">* array to write in the spreadsheet</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getApiData_</span>(<span class="params">url_query, query</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> totalData = []</span><br><span class="line">  <span class="keyword">var</span> areData = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> skip = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(areData)&#123;</span><br><span class="line">    <span class="keyword">var</span> queryIter = query.<span class="title function_">replace</span>(<span class="string">&quot;skip_param&quot;</span>, skip.<span class="title function_">toString</span>());</span><br><span class="line">    <span class="keyword">var</span> options = <span class="title function_">createOptions_</span>(queryIter)</span><br><span class="line">    <span class="keyword">var</span> response = <span class="title class_">UrlFetchApp</span>.<span class="title function_">fetch</span>(url_query, options)</span><br><span class="line">    <span class="keyword">var</span> json = response.<span class="title function_">getContentText</span>();</span><br><span class="line">    <span class="keyword">var</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(json);</span><br><span class="line">    <span class="keyword">var</span> arrayData = data[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;ftTransfers&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> grouped = arrayData.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> [ </span><br><span class="line">        e[<span class="string">&#x27;amount&#x27;</span>] / <span class="number">1e24</span>, </span><br><span class="line">        e[<span class="string">&#x27;to&#x27;</span>][<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">        e[<span class="string">&#x27;from&#x27;</span>][<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">        <span class="built_in">parseInt</span>(e[<span class="string">&#x27;timestamp&#x27;</span>] / <span class="number">1e6</span>)</span><br><span class="line">      ] </span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    totalData.<span class="title function_">push</span>(...grouped)</span><br><span class="line">    skip += <span class="number">1000</span></span><br><span class="line">    </span><br><span class="line">    areData = arrayData.<span class="property">length</span> &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> totalData</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后定义好trigger</p><p><img src="/uploads/upload_119ca787dbe45696248c42f2518855ad.png" alt=""></p><p>接着就可以去data studio尽情玩耍数据了，链接在这里:<a href="https://datastudio.google.com/reporting/6a034c50-3732-46d6-ab94-a7144fe2a816">https://datastudio.google.com/reporting/6a034c50-3732-46d6-ab94-a7144fe2a816</a> ，后面看看怎么做一个有方向的动态图</p><p><img src="/uploads/upload_b2b0acb81046ce857c02a929d2b033ee.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用TheGraph开发链上数据索引的一些总结&quot;&gt;&lt;a href=&quot;#使用TheGraph开发链上数据索引的一些总结&quot; class=&quot;headerlink&quot; title=&quot;使用TheGraph开发链上数据索引的一些总结&quot;&gt;&lt;/a&gt;使用TheGraph开发链上数据索
      
    
    </summary>
    
    
      <category term="NEAR" scheme="https://dispa1r.github.io/tags/NEAR/"/>
    
      <category term="Graph" scheme="https://dispa1r.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>Be a full stack hacker</title>
    <link href="https://dispa1r.github.io/2022/05/16/Be-a-full-stack-hacker/"/>
    <id>https://dispa1r.github.io/2022/05/16/Be-a-full-stack-hacker/</id>
    <published>2022-05-16T07:52:46.000Z</published>
    <updated>2022-05-16T07:53:52.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Make-a-dream"><a href="#Make-a-dream" class="headerlink" title="Make a dream"></a>Make a dream</h1><h2 id="Full-Stack"><a href="#Full-Stack" class="headerlink" title="Full Stack"></a>Full Stack</h2><p>争取在未来的日子里成为一个全栈开发者</p><p><img src="/uploads/upload_352b96b3845d80f343bab91458a453ac.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Make-a-dream&quot;&gt;&lt;a href=&quot;#Make-a-dream&quot; class=&quot;headerlink&quot; title=&quot;Make a dream&quot;&gt;&lt;/a&gt;Make a dream&lt;/h1&gt;&lt;h2 id=&quot;Full-Stack&quot;&gt;&lt;a href=&quot;#Ful
      
    
    </summary>
    
    
      <category term="废话" scheme="https://dispa1r.github.io/tags/%E5%BA%9F%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>Build NEAR app with Airtable/Glide</title>
    <link href="https://dispa1r.github.io/2022/05/04/Build-NEAR-app-with-Airtable-Glide/"/>
    <id>https://dispa1r.github.io/2022/05/04/Build-NEAR-app-with-Airtable-Glide/</id>
    <published>2022-05-04T11:24:20.000Z</published>
    <updated>2022-05-04T11:24:56.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Build-NEAR-app-with-Airtable-Glide-Welcome-Track"><a href="#Build-NEAR-app-with-Airtable-Glide-Welcome-Track" class="headerlink" title="Build NEAR app with Airtable/Glide(Welcome Track)"></a>Build NEAR app with Airtable/Glide(Welcome Track)</h1><p>本次演示中代码已上传到git： <a href="https://github.com/Dispa1r/NEAR-aritable">https://github.com/Dispa1r/NEAR-aritable</a></p><h2 id="关于新手赛道"><a href="#关于新手赛道" class="headerlink" title="关于新手赛道"></a>关于新手赛道</h2><p>新手赛道主要针对那些想要把应用集成到区块链中，以及想要熟悉该技术的非区块链开发人员，也就是说web3.0的新人。</p><ul><li>号召博雅教育。我们非常缺少哲学家和历史学家、艺术家和插画家的意见，他们的思维方式不会被限制，如果这一挑战引起了您的共鸣，那么今天就来帮助我们展望未来。创作原创或衍生作品，传达有关网络未来的宝贵信息——这可以是一篇论文、一幅画、一首歌或独白。使用最有效的媒介去制作您的作品。</li></ul><h3 id="新手赛道选题"><a href="#新手赛道选题" class="headerlink" title="新手赛道选题"></a>新手赛道选题</h3><h2 id="Bootcamp"><a href="#Bootcamp" class="headerlink" title="Bootcamp"></a>Bootcamp</h2><p>一般来说，学习编程的作品中会伴随很多demo的产生，将demo改造成一个web3的作评显得就很酷。</p><ul><li>可以NEAR账户系统融入你的作评的身份认证系统中</li><li>可以将原本中心化的存储，以及一些API和服务，将数据、代码等迁移至NEAR智能合约中</li></ul><h2 id="Airtable"><a href="#Airtable" class="headerlink" title="Airtable"></a>Airtable</h2><p>下一代的Excel，一些特点</p><ul><li>支持多人协作</li><li>多种特色的view</li><li>支持使用rest API写入外部数据</li><li>支持web hook等</li><li>一系列的自动化提高工作效率</li><li>可以导入google sheet等多方数据来源</li><li>丰富的案例与模板可供使用</li><li>便捷的脚手架，可以生成大量的demo代码</li></ul><h4 id="作为前端使用"><a href="#作为前端使用" class="headerlink" title="作为前端使用"></a>作为前端使用</h4><p>Airtable可以作为前端使用，在View中选择Form View，接着把表单链接分享给其他用户，那么你就得到了一个简易的前端。</p><p><img src="https://hackmd.summershrimp.com/uploads/upload_9d1a7bb17f00c904232b1ce53ba36f9a.png" alt=""></p><p>在airtable被写入数据后，使用automation工具调用封装好合约功能的API server即可实现数据的同步。</p><h4 id="作为后端使用"><a href="#作为后端使用" class="headerlink" title="作为后端使用"></a>作为后端使用</h4><p>Airtable也可以被看成一个简易的数据库中使用，通过JS bridge打通Airtable与合约之间的数据桥梁，也可以实现两者之间的数据同步。</p><p><img src="https://hackmd.summershrimp.com/uploads/upload_673155806cc56e02132882db69829f9e.png" alt=""></p><h2 id="NEAR-API-JS"><a href="#NEAR-API-JS" class="headerlink" title="NEAR API JS"></a>NEAR API JS</h2><p>利用API JS作为桥梁，打通Airtable和NEAR智能合约之间的数据流通，并且实现读写的原子性。引入airtable API与NEAR-API-JS，可以实现合约数据的可视化。</p><h2 id="其他选择"><a href="#其他选择" class="headerlink" title="其他选择"></a>其他选择</h2><ul><li>Glide：快速构建app，实现table数据的可视化，缺点：不支持使用API/SDK进行外部数据的读写，Glide在不久的将来也会支持Airtable作为data source，利用Glide与data source可以快速构建应用。</li><li>Google sheet：提供多种语言API，内置丰富的脚本，通过编写脚本可以实现特定板机触发时执行特定的任务。</li><li>AppSheet：Google提供的简易通过Google sheet构建App的工具，可以完美实现与Google sheet数据的流通。</li></ul><p><img src="https://hackmd.summershrimp.com/uploads/upload_b068e12692fd3e86455a66740d27ce2b.png" alt=""></p><h2 id="数据的binding"><a href="#数据的binding" class="headerlink" title="数据的binding"></a>数据的binding</h2><p>如何实现Table中数据与合约中数据的同步是一个问题，</p><ul><li>Glide 导入Google sheet的话，可以自动实现两者数据的同步</li><li>AirTable的话导入Google sheet之后，两者数据是独立的</li></ul><p>数据流：</p><ul><li>Contract -&gt; AirTable 可以通过js的方式实现数据的同步</li><li>Contract -&gt; Google Sheet 同上</li><li>AirTable -&gt; Contract 可以通过JS？或者email server，待探讨</li><li>GoogleSheet -&gt; Contract 参考Google Sheet script</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://airtable.com/api">https://airtable.com/api</a></li><li><a href="https://developers.google.com/apps-script/guides/sheets/connected-sheets">https://developers.google.com/apps-script/guides/sheets/connected-sheets</a></li><li><a href="https://go.glideapps.com/">https://go.glideapps.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Build-NEAR-app-with-Airtable-Glide-Welcome-Track&quot;&gt;&lt;a href=&quot;#Build-NEAR-app-with-Airtable-Glide-Welcome-Track&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="NEAR" scheme="https://dispa1r.github.io/tags/NEAR/"/>
    
  </entry>
  
  <entry>
    <title>Build a telegram red packet bot</title>
    <link href="https://dispa1r.github.io/2022/05/04/Build-a-telegram-red-packet-bot/"/>
    <id>https://dispa1r.github.io/2022/05/04/Build-a-telegram-red-packet-bot/</id>
    <published>2022-05-04T11:04:21.000Z</published>
    <updated>2022-05-04T11:05:08.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="How-to-write-a-telegram-red-packect-bot-on-NEAR"><a href="#How-to-write-a-telegram-red-packect-bot-on-NEAR" class="headerlink" title="How to write a telegram red packect bot on NEAR"></a>How to write a telegram red packect bot on NEAR</h1><p>In this tutorial, i will show you how to write a telegram red packect of near. There will be two parts, the contract and the robot part :)</p><h2 id="Ready-to-work"><a href="#Ready-to-work" class="headerlink" title="Ready to work"></a>Ready to work</h2><p>Before develop on near, you should have a testnet account to deploy and call the contract. You can register it at <a href="https://wallet.testnet.near.org/">NEAR testnet</a>.</p><p>And then, you should have <code>near-cli</code> and rust tool chain on your computer.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># install rust tool chain</span><br><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br><span class="line">rustup target add wasm32-unknown-unknown</span><br><span class="line"># install near-cli</span><br><span class="line">npm install near-cli -g</span><br><span class="line"># login the near account</span><br><span class="line">near login</span><br></pre></td></tr></table></figure><h2 id="Contract"><a href="#Contract" class="headerlink" title="Contract"></a>Contract</h2><p>You may need a little experience in rust development, but if you are someone who is not familiar with the rust language, but has a certain foundation of object-oriented programming, you don’t need to worry, because the contract code becomes very readable with the help of comments。</p><p>First we can find there has been a linkdrop contract deployed on both near testnet and mainnet. And we can find the repo of linkdrop <a href="https://github.com/near/near-linkdrop">here</a>.</p><p>First, we need to to analyse the code of contract. First, we need to understand how it stores the data. We should read the struct part first.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#[near_bindgen]</span><br><span class="line">#[derive(Default, BorshDeserialize, BorshSerialize)]</span><br><span class="line">pub struct LinkDrop &#123;</span><br><span class="line">    pub accounts: Map&lt;PublicKey, Balance&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The contract uses a map to store the public key and balance, it means how many near can someone who owns the private key corresponding to the public key get.Let us analyse the send function first :).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#[payable]</span><br><span class="line">pub fn send(&amp;mut self, public_key: Base58PublicKey) -&gt; Promise &#123;</span><br><span class="line">    assert!(</span><br><span class="line">        env::attached_deposit() &gt; ACCESS_KEY_ALLOWANCE,</span><br><span class="line">        &quot;Attached deposit must be greater than ACCESS_KEY_ALLOWANCE&quot;</span><br><span class="line">    );</span><br><span class="line">    let pk = public_key.into();</span><br><span class="line">    let value = self.accounts.get(&amp;pk).unwrap_or(0);</span><br><span class="line">    // insert the public key and balance into contract</span><br><span class="line">    self.accounts.insert(</span><br><span class="line">        &amp;pk,</span><br><span class="line">        &amp;(value + env::attached_deposit() - ACCESS_KEY_ALLOWANCE),</span><br><span class="line">    );</span><br><span class="line">    // the call back function</span><br><span class="line">    Promise::new(env::current_account_id()).add_access_key(</span><br><span class="line">        pk,</span><br><span class="line">        ACCESS_KEY_ALLOWANCE,</span><br><span class="line">        env::current_account_id(),</span><br><span class="line">        b&quot;claim,create_account_and_claim&quot;.to_vec(),</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can see that the parameter of the call is a public key, so before we call this function, we need to use near sdk to create a valid near key pair, and we seed the public key to the contract, give the private key to the people who we want to give the linkdrop. Let us see what the <code>add_access_key</code> function does.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/// Add an access key that is restricted to only calling a smart contract on some account using</span><br><span class="line">/// only a restricted set of methods. Here `method_names` is a comma separated list of methods,</span><br><span class="line">/// e.g. `b&quot;method_a,method_b&quot;`.</span><br><span class="line">pub fn add_access_key(</span><br><span class="line">    self,</span><br><span class="line">    public_key: PublicKey,</span><br><span class="line">    allowance: Balance,</span><br><span class="line">    receiver_id: AccountId,</span><br><span class="line">    method_names: Vec&lt;u8&gt;,</span><br><span class="line">) -&gt; Self &#123;</span><br><span class="line">    self.add_action(PromiseAction::AddAccessKey &#123;</span><br><span class="line">        public_key,</span><br><span class="line">        allowance,</span><br><span class="line">        receiver_id,</span><br><span class="line">        method_names,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This function will add a access key to the contract account. Public_key is the key we just created, people who use the corresponding private key to sign the transaction could call the <code>claim</code> function and <code>create_account_and_claim</code> function. So we can know the linkdrop contract use a keypair to confirm the safety of the linkdrop. People who owns the private key could get the balance of the drop.</p><h2 id="a-little-upgrade"><a href="#a-little-upgrade" class="headerlink" title="a little upgrade"></a>a little upgrade</h2><p>We can see that now the contract only can give one people linkdrop, maybe we could make it more cool. We can transform the contract to allow multiple users to receive the same red envelope, it’s the same as WeChat’s lucky red envelope. So we should add some different functions.</p><p>First, we should change the parameter: from single <code>Base58PublicKey</code> to a vector <code>Vec&lt;Base58PublicKey&gt;</code>, and set how many people can receive. Then we just need to change adding a record to the map from before to add multiple records. So, the <code>sendLuck</code> function should become as following:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pub fn send_luck(&amp;mut self, public_key: Vec&lt;Base58PublicKey&gt;, num: u128) -&gt; Promise &#123;</span><br><span class="line">        assert!(</span><br><span class="line">            env::attached_deposit() &gt; ACCESS_KEY_ALLOWANCE * num,</span><br><span class="line">            &quot;Attached deposit must be greater than ACCESS_KEY_ALLOWANCE&quot;</span><br><span class="line">        );</span><br><span class="line">        let mut copy = public_key;</span><br><span class="line">        let mut number = 0;</span><br><span class="line">        let mut person = num;</span><br><span class="line">        // evenly divide the balance</span><br><span class="line">        let mut avgAmount = remain_num / person;</span><br><span class="line">        while number != num &#123;</span><br><span class="line">            let pk   = copy.pop().unwrap().into();</span><br><span class="line">            let value = self.accounts.get(&amp;pk).unwrap_or(0);</span><br><span class="line">            let third = v.pop();</span><br><span class="line">            self.accounts.insert(</span><br><span class="line">                &amp;pk,</span><br><span class="line">                avgAmount),</span><br><span class="line">            );</span><br><span class="line">            Promise::new(env::current_account_id()).add_access_key(</span><br><span class="line">                pk,</span><br><span class="line">                ACCESS_KEY_ALLOWANCE,</span><br><span class="line">                env::current_account_id(),</span><br><span class="line">                b&quot;claim,create_account_and_claim&quot;.to_vec(),</span><br><span class="line">            );</span><br><span class="line">            number += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        Promise::new(env::current_account_id())</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>But we should make the game more exciting. We should make the amount of red envelopes received by everyone random. At the same time, the amount of red envelopes received by each person should be satisfied with the mean distribution. </p><p>Therefore, we can implement a double mean method, but the random number part may be unfortunate. In order to meet the consensus, there is no real random number on the blockchain, but you can rely on the oracle of <code>chainlink</code> to obtain a secure random number. However, the NEAR chain currently does not support <code>chainlink</code>. We believe in that it should be possible to use <code>chainlink</code> NEAR in the near future, so we use <code>block_timeStamp</code> to get a pseudo-random number.</p><p>So the code after upgrading should be like this:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#[payable]</span><br><span class="line">   pub fn send_luck(&amp;mut self, public_key: Vec&lt;Base58PublicKey&gt;, num: u128) -&gt; Promise &#123;</span><br><span class="line">       assert!(</span><br><span class="line">           env::attached_deposit() &gt; ACCESS_KEY_ALLOWANCE * num,</span><br><span class="line">           &quot;Attached deposit must be greater than ACCESS_KEY_ALLOWANCE&quot;</span><br><span class="line">       );</span><br><span class="line">       let mut copy = public_key;</span><br><span class="line">       let mut number = 0;</span><br><span class="line">       let mut remain_num = env::attached_deposit() - num * ACCESS_KEY_ALLOWANCE;</span><br><span class="line">       let mut v:Vec&lt;u128&gt; = Vec::new();</span><br><span class="line">       let mut person = num;</span><br><span class="line">       while number != num-1 &#123;</span><br><span class="line">           let mut avgAmount = remain_num / person;</span><br><span class="line">           let mut doubleAvgAmount = avgAmount * 2;</span><br><span class="line">           person -= 1;</span><br><span class="line">           let mut min = ACCESS_MIN_MONEY;</span><br><span class="line">           let mut max = doubleAvgAmount ;</span><br><span class="line">           let mut rand = MyRandomGenerator::default();</span><br><span class="line">           let mut timestamp = env::block_timestamp() as u128;</span><br><span class="line">           timestamp = timestamp % 100;</span><br><span class="line">           let mut currentAmount   =(rand.gen::&lt;u128&gt;() / timestamp) % max + min ;</span><br><span class="line">           v.push(currentAmount);</span><br><span class="line">           remain_num = remain_num - currentAmount;</span><br><span class="line">           number += 1;</span><br><span class="line">       &#125;</span><br><span class="line">       v.push(remain_num);</span><br><span class="line">       number = 0;</span><br><span class="line">       while number != num &#123;</span><br><span class="line">           let pk   = copy.pop().unwrap().into();</span><br><span class="line">           let value = self.accounts.get(&amp;pk).unwrap_or(0);</span><br><span class="line">           let third = v.pop();</span><br><span class="line">           self.accounts.insert(</span><br><span class="line">               &amp;pk,</span><br><span class="line">               &amp;(value + third.unwrap()),</span><br><span class="line">           );</span><br><span class="line">           Promise::new(env::current_account_id()).add_access_key(</span><br><span class="line">               pk,</span><br><span class="line">               ACCESS_KEY_ALLOWANCE,</span><br><span class="line">               env::current_account_id(),</span><br><span class="line">               b&quot;claim,create_account_and_claim&quot;.to_vec(),</span><br><span class="line">           );</span><br><span class="line">           number += 1;</span><br><span class="line">       &#125;</span><br><span class="line">       Promise::new(env::current_account_id())</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>Aha, we just finished to upgrade the contract, we don’t need to change the claim function beacuse we don’t change the storage structure.</p><h2 id="call-the-contract"><a href="#call-the-contract" class="headerlink" title="call the contract"></a>call the contract</h2><p>Due to space reasons, how to install and use near-js-sdk will not be introduced here, I will directly show how to call our contract in the node-js environment.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">// deploy contract function</span><br><span class="line">async function deployContract() &#123;</span><br><span class="line">    const near = await connect(config);</span><br><span class="line">    const account = await near.account(&quot;dispa1r.testnet&quot;);</span><br><span class="line">    const response = await account.deployContract(fs.readFileSync(&#x27;./linkdrop.wasm&#x27;));</span><br><span class="line">    console.log(response);</span><br><span class="line">&#125;</span><br><span class="line">const public_key = [];</span><br><span class="line">const nearPriAccount = [];</span><br><span class="line"></span><br><span class="line">## generate multiple keypair</span><br><span class="line">async function createKeyPair(newAccountId, num) &#123;</span><br><span class="line">    const keyStore1 = new keyStores.UnencryptedFileSystemKeyStore(&quot;./&quot;);</span><br><span class="line">    //const creatorAccount = await near.account(creatorAccountId);</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; num; i++) &#123;</span><br><span class="line">        const keyPair = KeyPair.fromRandom(&quot;ed25519&quot;);</span><br><span class="line">        await keyStore1.setKey(config.networkId, newAccountId + i, keyPair);</span><br><span class="line">        const KEY_PATH = &#x27;./testnet/&#x27; + newAccountId + i + &quot;.json&quot;;</span><br><span class="line">        const credentials = JSON.parse(fs.readFileSync(KEY_PATH));</span><br><span class="line">        //keyStore.setKey(NETWORK_ID, ACCOUNT_ID, KeyPair.fromString(credentials.private_key));</span><br><span class="line">        public_key.push(keyPair.publicKey.toString().replace(&#x27;ed25519:&#x27;, &#x27;&#x27;));</span><br><span class="line">        nearPriAccount.push(credentials.private_key.replace(&#x27;ed25519:&#x27;, &#x27;&#x27;));</span><br><span class="line">    &#125;</span><br><span class="line">    //console.log(public_key);</span><br><span class="line">    console.log(nearPriAccount);</span><br><span class="line">    //await keyStore.setKey(config.networkId, &quot;testnmsl1.testnet&quot;, keyPair)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function getContract(viewMethods = [], changeMethods = [], secretKey) &#123;</span><br><span class="line">    const near = await connect(config);</span><br><span class="line">    if (secretKey) &#123;</span><br><span class="line">        await keyStore.setKey(</span><br><span class="line">            NETWORK_ID, &quot;dispa1r.testnet&quot;,</span><br><span class="line">            nearAPI.KeyPair.fromString(secretKey)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    const tmpAccount = await near.account(&quot;dispa1r.testnet&quot;);</span><br><span class="line">    const contract = new nearAPI.Contract(tmpAccount, &quot;dispa1r.testnet&quot;, &#123;</span><br><span class="line">        viewMethods,</span><br><span class="line">        changeMethods,</span><br><span class="line">        sender: &quot;dispa1r.testnet&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">    return contract</span><br><span class="line">&#125;</span><br><span class="line">async function getContract1(viewMethods = [], changeMethods = []) &#123;</span><br><span class="line">    const near = await connect(config);</span><br><span class="line">    const tmpAccount = await near.account(&quot;dispa1r.testnet&quot;);</span><br><span class="line">    const signAccount = await near.account(&quot;dispa1r1.testnet&quot;);</span><br><span class="line">    const contract1 = new nearAPI.Contract(tmpAccount, &quot;dispa1r.testnet&quot;, &#123;</span><br><span class="line">        viewMethods,</span><br><span class="line">        changeMethods,</span><br><span class="line">        sender: tmpAccount</span><br><span class="line">    &#125;)</span><br><span class="line">    return contract1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// beginning send function</span><br><span class="line">async function callSend(public_key, deposit) &#123;</span><br><span class="line">    const contract = await getContract1([], [&#x27;send&#x27;])</span><br><span class="line">    const depositNum = toNear(deposit)</span><br><span class="line">    await contract.send(&#123;</span><br><span class="line">            public_key,</span><br><span class="line">        &#125;, 200000000000000, depositNum)</span><br><span class="line">        .then(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;Drop claimed&#x27;)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch((e) =&gt; &#123;</span><br><span class="line">            console.log(e)</span><br><span class="line">            console.log(&#x27;Unable to claim drop. The drop may have already been claimed.&#x27;)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// send Luck version</span><br><span class="line">async function callSendLuck(nearAmount, num) &#123;</span><br><span class="line">    await createKeyPair(&quot;test.testnet&quot;, num);</span><br><span class="line">    const contract = await getContract1([], [&#x27;send_luck&#x27;])</span><br><span class="line">    const deposit = toNear(nearAmount);</span><br><span class="line">    //console.log(public_key);</span><br><span class="line">    await contract.send_luck(&#123;</span><br><span class="line">            public_key,</span><br><span class="line">            num,</span><br><span class="line">        &#125;, 200000000000000, deposit)</span><br><span class="line">        .then(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;Drop claimed&#x27;)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch((e) =&gt; &#123;</span><br><span class="line">            console.log(e)</span><br><span class="line">            console.log(&#x27;Unable to claim drop. The drop may have already been claimed.&#x27;)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function claimDrop(account_id, privKey) &#123;</span><br><span class="line">    const contract = await getContract([], [&#x27;claim&#x27;, &#x27;create_account_and_claim&#x27;], privKey)</span><br><span class="line">        // return funds to current user</span><br><span class="line">    await contract.claim(&#123;</span><br><span class="line">            account_id,</span><br><span class="line">        &#125;, 200000000000000)</span><br><span class="line">        .then(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;Drop claimed&#x27;)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch((e) =&gt; &#123;</span><br><span class="line">            console.log(e)</span><br><span class="line">            console.log(&#x27;Unable to claim drop. The drop may have already been claimed.&#x27;)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Robot-part"><a href="#Robot-part" class="headerlink" title="Robot part"></a>Robot part</h2><p>I do not intend to introduce the robot part in detail, because I used someone else’s golang-based telegram robot framework. It is very simple. You can find all of my code on github. If you have any questions, you can directly send me a private message via Twitter.</p><p>I think i should briefly introduce the robot-related code, i just make some comments.</p><p>The way I implemented it is very inelegant, because near does not have go-api, but in fact you can choose api-server, but I didn’t know these at the time, so I chose to go through near-js-api and go. I calling the command line command to implement the call contract. You can see the related code in <code>utils.go</code> and the js code in <code>test.js</code>.</p><p>In my robot, people only could send red packet after sign in and deposit near to the robot account, so i write a simple spider to check the transaction of deposit.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">b.Handle(&quot;/deposit&quot;,func(m *tb.Message) &#123;</span><br><span class="line">b.Send(m.Sender, &quot;please transfer to the near account:dispa1r.testnet&quot;)</span><br><span class="line">b.Send(m.Sender, &quot;after transfer, please input your txn hash&quot;)</span><br><span class="line">b.Send(m.Sender, &quot;the deposit must be bigger than 1 near&quot;)</span><br><span class="line">b.Handle(tb.OnText, func(m *tb.Message) &#123;</span><br><span class="line">// all the text messages that weren&#x27;t</span><br><span class="line">// captured by existing handlers</span><br><span class="line">url := &quot;https://explorer.testnet.near.org/transactions/&quot; + m.Text</span><br><span class="line">result := Get(url)</span><br><span class="line">//fmt.Println(result)</span><br><span class="line">reg1 := regexp.MustCompile(`&quot;receiverId&quot;:&quot;(?s:(.*?)).testnet&quot;,`)</span><br><span class="line">result1 := reg1.FindAllStringSubmatch(result, -1)</span><br><span class="line">receiverId := result1[0][1]</span><br><span class="line">reg2 := regexp.MustCompile(`&quot;deposit&quot;:&quot;(?s:(.*?))&quot;,`)</span><br><span class="line">result1 = reg2.FindAllStringSubmatch(result, -1)</span><br><span class="line">tmp := result1[0][1]</span><br><span class="line">numOnly := strings.TrimSuffix(tmp, &quot;\&quot;&#125;&#125;],\&quot;status\&quot;:\&quot;SuccessValue&quot;)</span><br><span class="line">var numOnly1 string</span><br><span class="line">numOnly1 = strings.TrimSuffix(numOnly, &quot;0000000000000000000000&quot;)</span><br><span class="line">num,err := strconv.Atoi(numOnly1)</span><br><span class="line">num1 := float64(num)/100</span><br><span class="line">if err!=nil || num &lt;100&#123;</span><br><span class="line">b.Send(m.Sender, &quot;invalid number&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if receiverId != &quot;dispa1r&quot; &#123;</span><br><span class="line">b.Send(m.Sender, &quot;invalid transaction&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">err = common.GenerateTxn(m.Text)</span><br><span class="line">if err !=nil&#123;</span><br><span class="line">b.Send(m.Sender, &quot;invalid transaction&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">common.DepositMoney(m.Sender.ID, num1)</span><br><span class="line">num2 := strconv.FormatFloat(num1,&#x27;f&#x27;,5,32)</span><br><span class="line">str3 := &quot;success to deposit &quot;+num2+&quot; near&quot;</span><br><span class="line">b.Send(m.Sender, str3)</span><br><span class="line">return</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Then is the <code>send_luck</code> function and the <code>claim</code> function.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">b.Handle(&quot;/lucky&quot;,func(m *tb.Message) &#123;</span><br><span class="line">//chat := m.Chat</span><br><span class="line">b.Send(m.Sender, &quot;input the number of the near:&quot;)</span><br><span class="line">var amount float64</span><br><span class="line"></span><br><span class="line">b.Handle(tb.OnText, func(m *tb.Message) &#123;</span><br><span class="line">amount,err = strconv.ParseFloat(m.Text,10)</span><br><span class="line">result := common.CheckIfHave(m.Sender.ID,amount)</span><br><span class="line">if err !=nil || !result&#123;</span><br><span class="line">b.Send(m.Sender, &quot;invalid number, please go to deposit&quot;)</span><br><span class="line">&#125;</span><br><span class="line">b.Send(m.Sender, &quot;input the number of the red-packets:&quot;)</span><br><span class="line">b.Handle(tb.OnText, func(m *tb.Message) &#123;</span><br><span class="line">var num int</span><br><span class="line">num,err = strconv.Atoi(m.Text)</span><br><span class="line">if err !=nil&#123;</span><br><span class="line">b.Send(m.Sender, &quot;invalid number&quot;)</span><br><span class="line">&#125;</span><br><span class="line">var privateKey []string</span><br><span class="line">err,privateKey = CallSendLuckCmd(amount,num)</span><br><span class="line">if err!=nil&#123;</span><br><span class="line">common.SendLuck(m.Sender.ID,amount)</span><br><span class="line">&#125;</span><br><span class="line">b.Send(m.Sender, &quot;success to call the send luck,now give u the private key&quot;)</span><br><span class="line">for i := range privateKey&#123;</span><br><span class="line">b.Send(m.Sender, privateKey[i])</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">b.Handle(&quot;/claim&quot;,func(m *tb.Message) &#123;</span><br><span class="line">b.Send(m.Sender, &quot;please input the private key to claim the drop&quot;)</span><br><span class="line">result := common.CheckBinded(m.Sender.ID)</span><br><span class="line">if !result&#123;</span><br><span class="line">b.Send(m.Sender,&quot;please first bind the near account&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">b.Handle(tb.OnText, func(m *tb.Message) &#123;</span><br><span class="line">privateKey := m.Text</span><br><span class="line">accountId := common.GetAccountId(m.Sender.ID)</span><br><span class="line">err = CallClaim(accountId,privateKey)</span><br><span class="line">//result := common.CheckIfHave(m.Sender.ID,amount)</span><br><span class="line">if err !=nil || !result&#123;</span><br><span class="line">b.Send(m.Sender, &quot;fail to claim the drop&quot;)</span><br><span class="line">&#125;</span><br><span class="line">b.Send(m.Sender, &quot;success to claim the drop!&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>repo address : <a href="https://github.com/Dispa1r/NearLuckyRobot">Disp41r lucky robot</a></p><h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><p>If you are not familiar with the rust language, or even programming, then don’t worry, you can go to github to find other people’s code. </p><p>There are many interesting contracts in near-example, and they are also very helpful for you to learn how to develop on near. </p><p>After understanding the contract, try to modify it, then compile and deploy, gradually you will find that your understanding of it will be deeper. All in all, there is only one sentence, the industry is good at diligence, and more hands-on operations will make you become stronger.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;How-to-write-a-telegram-red-packect-bot-on-NEAR&quot;&gt;&lt;a href=&quot;#How-to-write-a-telegram-red-packect-bot-on-NEAR&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="NEAR" scheme="https://dispa1r.github.io/tags/NEAR/"/>
    
      <category term="Telegram bot" scheme="https://dispa1r.github.io/tags/Telegram-bot/"/>
    
  </entry>
  
  <entry>
    <title>联盟链跨链方案构想</title>
    <link href="https://dispa1r.github.io/2022/05/04/%E8%81%94%E7%9B%9F%E9%93%BE%E8%B7%A8%E9%93%BE%E6%96%B9%E6%A1%88%E6%9E%84%E6%83%B3/"/>
    <id>https://dispa1r.github.io/2022/05/04/联盟链跨链方案构想/</id>
    <published>2022-05-04T10:40:05.000Z</published>
    <updated>2022-05-04T10:41:47.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链上计算结果正确性"><a href="#链上计算结果正确性" class="headerlink" title="链上计算结果正确性"></a>链上计算结果正确性</h1><p>主要解决的问题是验证链上计算结果的真实性，由于联盟链本身没有PoW和PoS之类的共识算法，因此可以使用以太坊之类的公链（结点多，共识算法可靠）的智能合约去监管联盟链上合约的计算结果。<br><span id="more"></span></p><h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><p>LP问题的数据来源是区块链账本，账本中的数据可以由多个结点写入，写入数据时，数据格式为{Id：data}的格式，data可以为单个整数，也可以是数组。</p><h2 id="LP求解"><a href="#LP求解" class="headerlink" title="LP求解"></a>LP求解</h2><p>求解LP问题时，第一步是从账本中取数据，然后计算LP问题和其对偶问题，然后将计算结果和使用到的数据来源上传到其他合约中，可以以json的形式传输数据，在公链的合约中可以以哈希表之类的形式存储以进行快速查找和索引，哈希表的key是唯一指定id（可以来源于时间戳或者fabric目前的区块高度，方便进行溯源），哈希表的value是序列化后的计算数据，其中要存储的关键字段有LP问题的解和对偶问题的解，LP问题的数据来源（可以只存Id，也可也Id和data一起存），其他合约需要进行监管时，可以从本地合约中存储的数据进行计算校验。<br>其中校验部分分为三种情况，第一种是feasible，也就是说c <em> x严格等于b </em> y（已完成），对于infeasible的情况，给出的proof中包含原问题辅助问题的解，如果辅助问题最优值为0，那么说明原问题有解。</p><p><img src="https://hackmd.summershrimp.com/uploads/upload_8382efa59dc0b643341cb2fa503ac16d.png" alt=""></p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><ul><li>校验正确率，因为go语言的原因，对偶问题的解和原本的解有较小的误差，这个可以作为一个正确率的评判因素</li><li>对比链上计算结果耗时与校验耗时</li><li>对比直接从监管结点查询数据与直接从联盟链合约中取数据耗时</li><li>对比下主动上传数据与监管结点去取数据的复杂度</li><li>对比求解的LP问题的规模所需要的耗时，从小到大</li></ul><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h2 id="云端结点主动取数据"><a href="#云端结点主动取数据" class="headerlink" title="云端结点主动取数据"></a>云端结点主动取数据</h2><p>云端区块链主动去取数据，构建图或者树，或者KV？如果以{K:timeStamp;V:Data}的格式去存储数据，当云端区块链去联盟链取数据时，可能没法知道存储数据的时间，从而没法取到数据。</p><h2 id="另一种方案"><a href="#另一种方案" class="headerlink" title="另一种方案"></a>另一种方案</h2><p>借助一个监管结点，监管结点是位于联盟链那端的，云端区块链发出监管请求时，云端区块链的链码会去调用监管结点，从而获取到形如{K:timeStamp;V:data}的数据，然后数据传送到云端链码中进行校验，并且把校验结果写入云端的链中</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul><li>求解效率问题：因为链码实际上是一个docker的形式运行，并且docker的性能参数无法修改，因此求解速度很慢</li><li>数据解的问题:目前构造的数据，5<em>10矩阵，1000次测试中，600次是有解的，但是一旦矩阵规模10 </em> 100，就只有50组左右是有解的。</li><li></li></ul><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><ul><li>求解对偶问题时，是否有计算优化空间</li><li>是否有更好的方法存储数据</li><li>更优雅的监管，比如说以代理合约的形式，这样就不需要去修改原本合约</li></ul><h2 id="方案-2021-11-3"><a href="#方案-2021-11-3" class="headerlink" title="方案 2021.11.3"></a>方案 2021.11.3</h2><ul><li>1 被监管链结点将数据写入账本，格式为 id:data，id是唯一标识符</li><li>2 当需要计算时，合约从账本中取出数据，进行LP计算，并且把计算的结果以{timeStamp:data}的格式写入区块链账本，其中data包括LP问题的参数和解，（可以尝试下默克尔树，好处是可保证在传输过程中数据的安全性）</li><li>3 当监管链请求监管数据时，监管客户端收到监管请求后，通过调用嵌入的监管合约从账本中取出LP计算写入的数据，并且上传到监管链</li><li>4 监管链的合约收到数据之后，进行校验运算之后将校验结果以{timeStamp:result}的形式写入监管链账本，如果发现计算结果不正确，监管合约则会通知监管客户端</li></ul><p>新版本架构图：</p><p><img src="https://hackmd.summershrimp.com/uploads/upload_148a477ae114825cfd8ad65f02f8249d.png" alt=""></p><p>可以进行的对比实验：</p><ul><li>监管客户端使用{timeStamp:data}备份计算数据与不备份数据直接遍历查找的对比</li><li>两种模式：监管链主动索取数据与被监管链主动调用监管链的校验合约的优缺点以及效率</li></ul><h2 id="2021-11-11方案"><a href="#2021-11-11方案" class="headerlink" title="2021.11.11方案"></a>2021.11.11方案</h2><ul><li>1 被监管链中由数据生成的合约将数据写入账本，格式为{id:data}，其中id是自增的唯一标识符</li><li>2 当被监管链需要计算时，会按照id从小到大的顺序，以此取出数据，用来构建出解决LP问题所需要的A，c，b，然后进求解，如果有最优值，那么则接着计算对偶问题，最终把原问题的解x和对偶问题的解y，以{timeStamp:[x,y]}的格式写入账本之中，其中x和y是含有多个0的向量，可以将x和y组成一个稀疏矩阵后压缩存储，减少存储和通信上的开销</li><li>3 在计算完成之后，会将计算的参数A,c,b数据以{timeStamp(和上面的timeStamp是同一个值):[Id(A),Id(c),Id(b)]}的格式写入账本之中做溯源用，由于A,c，b都是大小比较相近的index，可以用整体加上或者减去一个整数的方法压缩存储。</li><li>4 监管链中有监管合约，合约中有一个监管函数，当调用监管函数之后，会像监管客户端发出一个rpc请求，监管客户端收到监管请求后，通过调用嵌入被监管链的监管合约从账本中取出LP计算结果和计算所用参数的id，接着利用id去账本中溯源到原本计算的数据，然后将整体数据打包后返回给监管链</li><li>5 监管链的合约收到数据之后，进行校验运算：1 验证A <em> x == b； 2  验证c </em> x == b * y；之后将校验结果以{timeStamp:result}的形式写入监管链账本，如果发现计算结果不正确，监管合约则会通知监管客户端</li><li>6 其实整体提出的是一个跨链监管框架，通过在被监管链方植入监管客户端和合约，然后通过在监管客户端中嵌入rpc服务器的方式实现跨链</li></ul><p>新版本架构图：</p><p><img src="https://hackmd.summershrimp.com/uploads/upload_148a477ae114825cfd8ad65f02f8249d.png" alt=""></p><p>可以进行的对比实验：</p><ul><li>监管客户端使用{timeStamp:data}备份计算数据与不备份数据直接遍历查找的对比</li><li>两种模式：监管链主动索取数据与被监管链主动调用监管链的校验合约的优缺点以及效率</li></ul><h2 id="2021-11-17方案"><a href="#2021-11-17方案" class="headerlink" title="2021.11.17方案"></a>2021.11.17方案</h2><p>结果可验证的轻量级联盟链跨链框架<br>应该是提出一个框架性的东西，其中LP计算是一个例子或者部分。提出的应该是一种结果可验证的跨链机制。我觉得可以叫基于中继结点（公证人）的可验证跨链机制。</p><p><img src="https://hackmd.summershrimp.com/uploads/upload_0cdec859310efbf60ca9f2c1241a05cb.png" alt=""></p><p>其中中继结点包含一个分布式kv数据库etcd和消息队列构成，同时具有RPC的功能，任何想要接入跨链框架的链第一步都是需要到中继结点中注册自己的身份信息，etcd需要存储的信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">K：链的ID</span><br><span class="line">V：&#123;链的名称，链的跨链路由ip地址，链的公钥，链的身份（监管者与被监管者）&#125;</span><br></pre></td></tr></table></figure><p>而链与链之间的通信都需要经过中继结点，所有的通信记录都会按照时间顺序存在中继节点的消息队列中，跨链路由是由接入链的SDK+RPC结点构成，同时也具有消息队列，可以存储发来的跨链调用请求，这样既实现了对接入链的信息的访问，又实现了链与链之间的互联互通。这些都是和目前现有的一些跨链框架设计理念差不多，但是中继结点更加轻量级和高效，设计思想类似于目前后端中的微服务的架构与模式。</p><p>具体的监管过程如下，以LP为例：</p><ul><li>1 被监管链中由数据生成的合约将数据写入账本，格式为{id:data}，其中id是自增的唯一标识符</li><li>2 当被监管链需要计算时，会按照id从小到大的顺序，以此取出数据，用来构建出解决LP问题所需要的A，c，b，然后进求解，如果有最优值，那么则接着计算对偶问题，最终把原问题的解x和对偶问题的解y，以{timeStamp:[x,y]}的格式写入账本之中，其中x和y是含有多个0的向量，可以将x和y组成一个稀疏矩阵后压缩存储，减少存储和通信上的开销</li><li>3 在计算完成之后，会将计算的参数A,c,b数据以{timeStamp(和上面的timeStamp是同一个值):[Id(A),Id(c ),Id(b)]}的格式写入账本之中做溯源用，由于A,c，b都是大小比较相近的index，可以用整体加上或者减去一个整数的方法压缩存储。</li><li>4 监管链中有监管合约，合约中有一个监管函数，当调用监管函数之后，监管函数会把监管请求发送到跨链路由，跨链路由接着会构建一个监管请求：{监管链ID，被监管链的id，监管的计算类型}，同时用自己保存在跨链路由中的私钥对消息使用RSA算法签名，把签名附加在消息中，接着消息将传递到中继结点中。</li><li>5 中继结点收到跨链路由的消息之后，会将消息发送至被监管链的跨链路由中，被监管链的跨链路由会向中继结点申请监管链的公钥，用来验证消息的合法性，同时会向中继结点索要监管链的id所对应的身份信息，判断是否为监管者，通过校验之后才会进行下面的操作。</li><li>6 被监管链跨链路由通过调用嵌入被监管链的监管合约从账本中取出LP计算结果和计算所用参数的id，接着利用id去账本中溯源到原本计算的数据，然后将整体数据打包后返回给监管链，同时会用自己的私钥将消息签名发送到中继结点中,消息格式{被监管链ID，监管链ID，Proof字段（根据不同的计算类型有不同的数据，在LP中是A,b,c,X,Y）}。</li><li>7 监管链在收到数据之后，向中继结点索取被监管链的公钥之后验证消息的合法性，进行校验运算：1 验证A <em> x == b； 2  验证c </em> x == b * y；之后将校验结果以{timeStamp:result}的形式写入监管链账本，如果发现计算结果不正确，监管合约则会通知监管客户端</li></ul><p>可对比的方案：</p><ul><li>异构能源区块链的多能互补安全交易模型</li><li>适用于异构联盟链底层平台的跨链模型</li><li>wecross</li><li>这两天即将发布的陆羽跨链模型</li></ul><p>创新点：</p><ul><li>使用了中继结点的方式，中继结点保存所有消息记录（可以划分为公证人跨链机制）</li><li>往常跨链中各个链身份都是平等的，我们引入了监管与被监管者的概念</li><li>设计了一系列的消息协议，用来确保跨链过程中的安全</li><li>设计的协议中跨链结果中带有proof字段，用来验证跨链结果的正确性]</li></ul><h2 id="方案简介"><a href="#方案简介" class="headerlink" title="方案简介"></a>方案简介</h2><p>在目前设计的系统中，信息巡查和数据处理结果的正确性，主要是指判断合约计算的结果是否正确，以税务系统的联盟链为例，一些税额的计算都是在智能合约中完成，因此我们需要去监管和验证智能合约计算结果的正确性，针对不同类型的运算有不同的验证机制，以线性规划问题为例，我们通过对偶问题去验证原问题是否计算正确，通过跨链技术和可验证计算技术相结合，实现跨链监管结果可溯源和不可篡改。<br>目前已经设计了一套轻量级的基于中继结点联盟链跨链监管框架，严格意义上可以划分于公证人跨链机制。中继节点由分布式KV数据库和消息队列组成，同时具有发起和接受RPC请求的功能，任何想要接入跨链监管框架的链第一步都是需要到中继结点中注册自己的身份信息，其中关键的身份信息有：1 自己的身份，该链在跨链系统中属于监管者还是被监管者；2 该链的公钥，私钥由区块链本身保存，公钥和私钥用于在进行跨链通信中确定和验证身份；3 该链的跨链路由的RPC地址，用于与结点之间进行互相通信。<br>联盟链向中继节点注册身份信息之后，需要接入特定的跨链路由，之后通过跨链路由，和设计的一套跨链监管消息通信协议，就可以实现监管链与被监管链之间的跨链通信和合约调用。</p><h2 id="本方法优点"><a href="#本方法优点" class="headerlink" title="本方法优点"></a>本方法优点</h2><p>1 使用了中继结点的方式，中继结点保存所有消息记录，因此所有跨链操作都是可以溯源和查询的.<br>2 相比较于中继链的跨链机制，中继链需要将跨链操作信息经过共识打包进交易，而中继结点相对来说处理交易的速度更快，并且通过消息队列的方式也可以实现交易信息全流程的存储。<br>3 相较于传统的联盟链跨链框架，我们的框架有了明确的身份划分，每一条接入的链必须是监管者或者被监管者，这样严格的身份控制可以确保整个跨链监管的安全性。<br>4 设计的消息通信协议中，我们加入了proof字段，通过proof字段携带的信息可以对不同类型的计算进行计算结果正确性的校验。</p><h2 id="场景变更"><a href="#场景变更" class="headerlink" title="场景变更"></a>场景变更</h2><p>一共有三条链，被监管链，中继链，监管链</p><p>被监管链进行LP计算，但是计算结果可能不正确，或者在将计算结果写入数据接收链的时候不正确（返回fake value给接收链），因此需要使用监管链进行监管。</p><p>角色增加为三个，1 被监管链 2 中继链 3 监管链<br>等于说把中继结点改成了中继链，注册，身份校验等不变，只是写在kv数据库中改成了写入身份信息合约中。<br>监管步骤：</p><ul><li>1 被监管链写入数据并且进行LP计算</li><li>2 被监管链定时将计算结果和Proof一定参数发送至接收链（根据不同的计算有不同的参数和结果，以LP为例，参数是数据的id，结果就是计算结果）</li><li>3 监管链想要进行监管时，首先需要向中继链提出监管请求，并且使用中继链的私钥对请求进行签名，接着中继链会把计算用到参数的id给监管链，监管链带着签名后的请求，可以去被监管链中取出data，和对偶问题的解</li><li>4 监管链会嵌入一个监管合约，监管合约会实时的计算原本LP问题的对偶问题，并且把</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;链上计算结果正确性&quot;&gt;&lt;a href=&quot;#链上计算结果正确性&quot; class=&quot;headerlink&quot; title=&quot;链上计算结果正确性&quot;&gt;&lt;/a&gt;链上计算结果正确性&lt;/h1&gt;&lt;p&gt;主要解决的问题是验证链上计算结果的真实性，由于联盟链本身没有PoW和PoS之类的共识算法，因此可以使用以太坊之类的公链（结点多，共识算法可靠）的智能合约去监管联盟链上合约的计算结果。&lt;br&gt;
    
    </summary>
    
    
      <category term="跨链" scheme="https://dispa1r.github.io/tags/%E8%B7%A8%E9%93%BE/"/>
    
      <category term="fabric" scheme="https://dispa1r.github.io/tags/fabric/"/>
    
  </entry>
  
  <entry>
    <title>重生</title>
    <link href="https://dispa1r.github.io/2022/05/04/index/"/>
    <id>https://dispa1r.github.io/2022/05/04/index/</id>
    <published>2022-05-04T09:40:05.000Z</published>
    <updated>2022-05-04T11:02:21.314Z</updated>
    
    <content type="html"><![CDATA[<p>在web3的世界里大展身手吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在web3的世界里大展身手吧！&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="废话" scheme="https://dispa1r.github.io/tags/%E5%BA%9F%E8%AF%9D/"/>
    
  </entry>
  
</feed>
